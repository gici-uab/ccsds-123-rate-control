package GiciEntropyCoder.ArithmeticCoder;

import java.io.IOException;
import java.io.OutputStream;

import GiciException.*;


/**
 * This class encodes bits belonging to the fractional bit plane coder of JPEG2000, coding them with the MQ coder. This class allows the use of the MQ with the options: restart, reset, bypass. Usage example:<br>
 * &nbsp; construct<br>
 * &nbsp; codeBit<br>
 * &nbsp; codeBit<br>
 * &nbsp; terminateOptimal | terminate<br>
 * &nbsp; reset<br>
 * &nbsp; swapOutputByteStream<br>
 * &nbsp; restart<br>
 * &nbsp; codeBit<br>
 * &nbsp; codeBit<br>
 * &nbsp; ...<br>
 *
 * @author Group on Interactive Coding of Images (GICI)
 * @version 1.2
 */
public class DumbMQCoder {

	/**
	 * OutputStream where the generated bytes are flushed
	 *<p>
	 * The resulting Stream can be empty when optimal terminations are used.
	 */	
	final class SmallByteStream {
		// This could be optimized for extremely fast insertion by
		// not using an addition and a modulo operation in addByte
		// and checking for a warp condition instead of a buffer full.
		
		OutputStream outputStream;
		
		final int halfSize = 4096 * 8;
		final int maxSize = 2 * halfSize; // This has to be a multiple of 2.
		final byte[] circularBuffer = new byte[maxSize];
		
		int start = 0;
		int used = 0;
		int totalWriten = 0;
		
		SmallByteStream (OutputStream outputStream) {
			this.outputStream = outputStream;
		}

		public void addByte(byte tr) throws IOException {		
			circularBuffer[(start + used) % maxSize] = tr;
			used++;
			
			if (used == maxSize) {
				flushHalf();
			}
		}

		public void flushHalf() throws IOException {
			int amount = halfSize;
			
			assert (amount <= used);
			assert (start == 0 || start == maxSize / 2);
			
			outputStream.write(circularBuffer, start, amount);
			
			start = (start + amount) % maxSize;
			used -= amount;
			
			totalWriten += amount;
		}
		
		public void flush() throws IOException {
			if (used > maxSize / 2) {
				flushHalf();
			}
			
			outputStream.write(circularBuffer, start, used);
			
			start = 0;
			used = 0;
			totalWriten = 0;
		}

		public void deleteEndBytes(int i) {
			// Ensure that the amount of bytes we are trying to delete is small enough so that is buffered
			assert (i <= used);
			used -= i;
		}

		public int getNumBytes() {
			return totalWriten + used;
		}

		public int getByte(int i) {
			// Ensure that the byte requested is in the buffered byte range
			assert (totalWriten <= i && i < totalWriten + used);
			
			return circularBuffer[(start + (i - totalWriten)) % maxSize];
		}
	};
	
	SmallByteStream outputByteStream;

	/**
	 * Interval range.
	 * <p>
	 * From right to left: 8 register bits, 3 spacer bits, 8 partial code byte, 1 carry bit.
	 */
	private int A;

	/**
	 * Lower down interval.
	 * <p>
	 * From right to left: 8 register bits, 3 spacer bits, 8 partial code byte, 1 carry bit.
	 */
	private int C;

	/**
	 * Number of bits to transfer (down counter).
	 * <p>
	 * Usually it is initialized to 8, unless carry situations that it initialized to 7. Then count down until 0.
	 */
	private int t;

	/**
	 * Byte to transfer.
	 * <p>
	 * Byte flushed to the outputByteStream.
	 */
	private int Tr;

	/**
	 * Number of bytes transferred to the outputByteStream.
	 * <p>
	 * Byte flushed to the output ByteStream.
	 */
	private int L;

	/**
	 * Constructor that initializes internal registers of MQ coder.
	 *
	 * @param outputByteStream ByteStream where the bytes are flushed
	 */
	public DumbMQCoder(OutputStream outputStream){
		this.outputByteStream = new SmallByteStream(outputStream);
		//Initialize internal registers
		restart();
	}

	/**
	 * Code a bit.
	 *
	 * @param bit bit to encode
	 * @param probability for the bit to be 1 (from 0x0001 to 0xAC01, where 0x5601 is 0.5?)
	 * @throws IOException 
	 */
	public void encodeBitProb(boolean bit, int probability) throws IOException{
		
		assert (probability >= 0x0001 && probability <= 0xAC01);
		boolean mostProbableSymbol = false;
		
		if (probability > 0x5601) {
			mostProbableSymbol = true;
			probability = 0xAC02 - probability;
		}
		
		int x = bit ? 1 : 0;
		int p = probability;
		int s = mostProbableSymbol ? 1 : 0;
			
		// OPTIMIZATION OF JPEG2000 BOOK (p 646) by Taubman/Marcellin
		A -= p;
		if(x == s){ //MPS coding
			if(A >= (1 << 15)){
				C += p;
			}else{
				if(A < p){
					A = p;
				}else{
					C += p;
				}
				
				while(A < (1 << 15)){
					A <<= 1;
					C <<= 1;
					t--;
					if(t == 0){
						transferByte();
					}
				}
			}
		}else{ //LPS coding
			if(A < p){
				C += p;
			}else{
				A = p;
			}
			
			while(A < (1 << 15)){
				A <<= 1;
				C <<= 1;
				t--;
				if(t == 0){
					transferByte();
				}
			}
		}
		
		/*
		// "NORMAL" ALGORITHM
		A -= p;
		
		// Conditional exchange of MPS and LPS in order to associate the longest interval (p or A) to the MPS.
		if (A < p) {
			s = 1 - s;
		}
		if (x == s) {
			//Assign MPS the upper sub-interval
			C += p;
		} else {
			//Assign LPS the lower sub-interval
			A = p;
		}

		// Perform re-normalization shift. All left zeroes in A (16 bits) are bits of C that should be transmitted.
		// Bits are written in the output buffer only when the down counter t is zero.
		while (A < (1 << 15)) {
			A <<= 1;
			C <<= 1;
			t--;
			if (t == 0) {
				//There is a full byte to be transmitted
				transferByte();
			}
		}
		*/
	}

	/**
	 * This function transfer a byte to the outputByteStream taken its content from C.
	 * @throws IOException 
	 */
	private void transferByte() throws IOException{
		if(Tr == 0xFF){ //Bit stuff
			outputByteStream.addByte((byte) Tr);
			L++;
			Tr = (C >>> 20); //Put C_msbs to Tr
			C &= (~0xFFF00000); //Put 0 to C_msbs
			t = 7;
		}else{
			if(C >= 0x08000000){
				//Propagate any carry bit from C into Tr
				Tr += 0x01;
				C &= (~0xF8000000); //Reset the carry bit
			}
			if(L >= 0){
				outputByteStream.addByte((byte) Tr);
			}
			L++;
			if(Tr == 0xFF){ //Bit stuff
				//Even though it may not be a bit carry in this case, we should write, after a FFh value, a byte like c000bbbb, because the decoder con not tell the difference between both cases
				Tr = (C >>> 20); //Put C_msbs to Tr
				C &= (~0xFFF00000); //Put 0 to C_msbs
				t = 7;
			}else{
				Tr = (C >>> 19); //Put C_partial to Tr
				C &= (~0xFFF80000); //Put 0 to C_partial
				t = 8;
			}
		}
	}

	/**
	 * Restart the value of the internal variables A, C, ... of the MQ coder, in other words, restarts the MQ coder althought the context probabilities are maintained. This function does NOT terminate the current ByteStream (the codestream should be terminated before to call this function using the terminate functions).
	 */
	private void restart(){
		A  = 0x8000;
		C  = 0;
		t = 12;
		Tr = (byte) 0;
		L = -1;
	}

	/**
	 * Finishes the current outputByteStream using the termination optimal, used by default. After calling this function you should call the restart function or swapOutputByteStream+restart.
	 *
	 * @throws WarningException when some problem with the manipulation of the ByteStream happens
	 */
	public void terminate() throws IOException{
		terminateOptimal();			
		//terminateEasy();
		
		outputByteStream.flush();
	}

	/**
	 * Finishes the current outputByteStream using easy termination, i.e. flushing all the remaining bits of the C register to the output ByteStream. After calling this function you should call the restart function or swapOutputByteStream+restart.
	 * @throws IOException 
	 */
	public void terminateEasy() throws IOException{
		//Easy MQ codeword termination
		int nBits = 27 - 15 - t;
		C <<= t;
		while(nBits > 0){
			transferByte();
			nBits -= t;
			C <<= t;
		}
		transferByte();

		//If last byte is 0xFF, delete it because MQ cannot terminate in this way (decoder puts all these bits to 1)
		if(t == 7){
			outputByteStream.deleteEndBytes(1);
		}
	}

	/**
	 * Finishes the current outputByteStream using easy termination, i.e. flushing all the remaining bits of the C register to the output ByteStream. After calling this function you should call the restart function or swapOutputByteStream+restart.
	 * @throws WarningException 
	 *
	 * @throws WarningException when some problem with the manipulation of the ByteStream happens
	 */
	private void terminateOptimal() throws IOException{
		//Normalization state variables
		int NZTr = Tr;
		int NZt = t;
		int NZC = C;
		int NZA = A;
		int NZL = L;

		//Length without easy termination
		int lengthEmptyTermination = outputByteStream.getNumBytes();

		//First we must terminate the stream in an easy way
		terminateEasy();

		int necessaryBytes = minFlush(NZTr, NZt, NZC, NZA, NZL, lengthEmptyTermination);

		//outputByteStream length with the optimal termination
		int lengthOptimalTermination = lengthEmptyTermination + necessaryBytes;

		// Note that 0xff and 0xff 0x7f should not have happened when terminating with easy mode, but check again
		if (lengthOptimalTermination >= 1) {
			if (outputByteStream.getByte(lengthOptimalTermination - 1) == 0xFF) {
				lengthOptimalTermination--;
			}
		}
		
		boolean elimination;
		do {
			elimination = false;
			if (lengthOptimalTermination >= 2) {
				if ((outputByteStream.getByte(lengthOptimalTermination - 2) == 0xFF)
						&& (outputByteStream.getByte(lengthOptimalTermination - 1) == 0x7F)) {
					lengthOptimalTermination -= 2;
					elimination = true;
				}
			}
		} while (elimination);

		//Remove unwanted bytes
		outputByteStream.deleteEndBytes(outputByteStream.getNumBytes() - lengthOptimalTermination);
	}

	/**
	 * Determine the minimum number of bytes needed to terminate ByteStream assuring a complete
	 * recovery (MQ decoder fills the ByteStreams with with 0x00 bytes?).
	 * Algorithm extracted from the book of JPEG2000 by Taubman and Marcellin.
	 *
	 * @param NZTr Tr register for the normalization
	 * @param NZt t register for the normalization
	 * @param NZC C register for the normalization
	 * @param NZA A register for the normalization
	 * @param NZL number of bytes flushed
	 * @param lengthEmptyTermination length bytes used by the easy termination
	 * @return the number of bytes that should be flushed to terminate the ByteStream optimally
	 *
	 * @throws WarningException when some problem with the manipulation of the ByteStream happens
	 */
	private int minFlush(int NZTr, int NZt, int NZC, int NZA, int NZL, int lengthEmptyTermination) throws IOException {
		// Real counterparts
		long Cr = ((long) NZTr << 27) + ((long) NZC << NZt);
		long Ar = (long) NZA << NZt;

		// Decoder
		long Rf = 0;
		int s = 8;
		int Sf = 35;

		// What we are looking for
		int necessaryBytes = 0;

		// If we have necessaryBytes greater than that we cut more bytes than we have
		int maxNecessaryBytes = 5;
		int cutZone = outputByteStream.getNumBytes() - lengthEmptyTermination;
		if(maxNecessaryBytes > cutZone){
			maxNecessaryBytes = cutZone;
		}

		if (lengthEmptyTermination == 0) {
			//Make sure A and C are normalized
			if ((((Cr >> 32) & 0xFF) == 0x00) && (NZL == -1)) {
				Cr = Cr << 8;
				Ar = Ar << 8;
			}
		}

		//Check if we are out of bounds to know if we should continue (out of bounds => next byte)
		while ((necessaryBytes < maxNecessaryBytes) 
				&& ((Rf + ((long) 1 << Sf) - 1 < Cr) || (Rf + ((long) 1 << Sf) - 1 >= Cr + Ar))) {
			necessaryBytes++;
			if (necessaryBytes <= 4) {
				//Decode one byte more
				Sf -= s;
				long b = outputByteStream.getByte(lengthEmptyTermination + necessaryBytes - 1);
				if (b < 0) {
					b += 256;
				}
				Rf += b << Sf;
				if (b == 0xFF) {
					s = 7;
				} else {
					s = 8;
				}
			}
		}
		return(necessaryBytes);
	}

}
